###### Ответ
3. Почему Singleton антипатерн,
 - нарушение принципа единой отвественности, Singleton-класс отвечает 
 сразу за две вещи: за то, что класс имеет лишь один объект, и за 
 реализацию того, для чего этот класс вообще был создан  
 - скрытая зависимость от Singleton-класса. Зависимость обычного класса
 от синглтона не видна в публичном 
 контракте класса. Так как обычно экземпляр синглтона не передается в 
 параметрах метода, а получается напрямую, через getInstance(), то для 
 выявления зависимости класса от синглтона надо залезть в тело каждого
 метода — просто просмотреть публичный контракт объекта недостаточно. 
 Как следствие: сложность рефакторинга при последующей замене синглтона 
 на объект, содержащий несколько экземпляров.  
 - он сильно затрудняет юнит-тестирование. “Одиночка” привносит в 
 программу глобальное состояние, поэтому вы не можете просто взять и 
 изолировать классы (заменить Mock объектом), которые полагаются на 
 Singelton. Поэтому, если вы хотите протестировать какой-то класс, то вы
 обязаны вместе с ним тестировать и Singleton, но это ещё полбеды. 
 Если Singelton имеет интерфейс для изменения своего состояния, это 
 порождает следующие проблемы:
     * Порядок тестов теперь имеет значение;
     * Тесты могут иметь нежелательные сторонние эффекты, порождённые 
    Singleton’ом;
     * Вы не можете запускать несколько тестов параллельно;
     * Несколько вызовов одного и того же теста могут приводить к разным
      результатам.
 - возможность создания новых объектов, самом деле стандартная реализация 
 Singleton не запрещает создавать новые объекты. Она запрещает создавать
 новые объекты через конструктор. А ведь существуют и другие способы 
 создать экземпляр класса, и один из них — сериализация и десериализация.
 Полной защиты от намеренного создания второго экземпляра Singelton’а 
 можно добиться только с помощью использования enum’а с единственным 
 состоянием, но это — неоправданное злоупотребление возможностями языка,
 ведь очевидно, что enum был придуман не для этого.
 - проблемы мультипоточности, любой код может использовать синглтон, 
 поэтому сложнее контролировать, из каких потоков он используется и 
 не изменяют ли его из разных потоков одновременно.
 - Рефлексия. Мы запрещаем создавать несколько экземпляров класса, 
 помечая конструктор приватным. Тем не менее, используя рефлексию, можно
 без особого труда изменить видимость конструктора с private на public 
 прямо во время исполнения. Если разрабатывается модуль, который затем 
 будет использоваться в сторонних приложениях, то из-за этого могут 
 возникнуть проблемы. Какие именно, зависит от того, что делает 
 ваш “Одиночка” — это могут быть как и риски, связанные с безопасностью,
 так и просто непредсказуемое поведение модуля. 
 - Загрузчик класса. Если говорить о Java, то обеспечение существования 
 лишь одного экземпляра класса, которое так необходимо для Singleton, 
 становится всё сложнее. Проблема в том, что классическая реализация 
 не проверяет, существует ли один экземпляр на JVM, он лишь 
 удостоверяется, что существует один экземпляр на classloader. Если вы 
 пишете небольшое клиентское приложение, в котором используется лишь 
 один classloader, то никаких проблем не возникнет. Однако если вы 
 используете несколько загрузчиков класса или ваше приложение должно 
 работать на сервере (где может быть запущено несколько экземпляров 
 приложения в разных загрузчиках классов), то всё становится очень 
 печально.
    
    